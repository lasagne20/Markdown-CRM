bbdcf2ed0fe360c85ece9dd2d6f9032b
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RangeDateProperty = void 0;
const flatpickr_1 = __importDefault(require("flatpickr"));
require("flatpickr/dist/l10n/fr.js");
const DateProperty_1 = require("./DateProperty");
class RangeDateProperty extends DateProperty_1.DateProperty {
    constructor(name, args = {}) {
        super(name, [], args);
        this.type = "dateRange";
    }
    createFieldDate(value, update, link) {
        const input = document.createElement("input");
        input.type = "text";
        input.value = value || ""; // Formaté en "YYYY-MM-DD" pour le stockage
        input.classList.add("field-input");
        (0, flatpickr_1.default)(input, {
            dateFormat: "Y-m-d", // Stocker en "YYYY-MM-DD"
            defaultDate: value || "",
            locale: "fr", // Utilisation de la langue française pour l'affichage
            mode: "range", // Permet de sélectionner une plage de dates
            onChange: async (selectedDates) => {
                if (selectedDates.length === 2) {
                    const startDate = selectedDates[0];
                    const endDate = selectedDates[1];
                    if (startDate && endDate) {
                        // Met à jour la valeur de l'input avec le format "YYYY-MM-DD to YYYY-MM-DD"
                        if (startDate.getTime() === endDate.getTime()) {
                            input.value = this.formatDateForStorage(startDate);
                        }
                        else {
                            input.value = `${this.formatDateForStorage(startDate)} to ${this.formatDateForStorage(endDate)}`;
                        }
                        await this.updateField(update, input, link);
                    }
                }
            },
            onClose: async () => await this.updateField(update, input, link)
        });
        return input;
    }
    // Crée un lien qui affiche la plage de dates (au format "26 février 2025 au 28 février 2025")
    createFieldLink(value) {
        const link = document.createElement("div");
        link.textContent = value ? this.formatDateRangeForDisplay(value) : "Aucune date sélectionnée";
        link.classList.add("date-field-link");
        link.classList.add("field-link");
        link.style.cursor = "pointer";
        link.onclick = (event) => this.modifyField(event);
        return link;
    }
    // Formate la plage de dates pour l'affichage : "26 février 2025" ou "26 février 2025 au 28 février 2025"
    formatDateRangeForDisplay(dateRange) {
        const [startDate, endDate] = dateRange.split(" to ");
        const formattedStartDate = new Date(startDate).toLocaleDateString("fr-FR", {
            weekday: "long",
            day: "numeric",
            month: "long",
            year: "numeric"
        });
        if (!endDate) {
            return `${formattedStartDate}`;
        }
        const formattedEndDate = new Date(endDate).toLocaleDateString("fr-FR", {
            weekday: "long",
            day: "numeric",
            month: "long",
            year: "numeric"
        });
        return `${formattedStartDate} au ${formattedEndDate}`;
    }
    // Crée un conteneur pour afficher la plage de dates et la sélection rapide
    createFieldContainerContent(update, value) {
        const fieldContainer = document.createElement("div");
        fieldContainer.classList.add("field-container");
        fieldContainer.classList.add("metadata-field");
        const currentField = value;
        const link = this.createFieldLink(currentField);
        const input = this.createFieldDate(currentField, update, link);
        // Affichage initial : Si la plage de dates existe, afficher le lien
        if (currentField && this.validate(value)) {
            link.style.display = "block";
            input.style.display = "none";
        }
        else {
            input.style.display = "block";
            link.style.display = "none";
        }
        fieldContainer.appendChild(link);
        fieldContainer.appendChild(input);
        return fieldContainer;
    }
    // Met à jour la valeur de la plage de dates et bascule l'affichage entre le lien et l'input
    async updateField(update, input, link) {
        let value = this.validate(input.value);
        if (value) {
            await update(value); // Met à jour avec la plage de dates au format "YYYY-MM-DD to YYYY-MM-DD"
            input.style.display = "none";
            link.textContent = this.formatDateRangeForDisplay(value); // Affichage avec le mois en lettres
            link.style.display = "block";
        }
        else {
            await update(input.value);
        }
    }
    // Valide la plage de dates au format "YYYY-MM-DD to YYYY-MM-DD"
    validate(value) {
        const dateRangeRegex = /^\d{4}-\d{2}-\d{2}( to \d{4}-\d{2}-\d{2})?$/;
        return dateRangeRegex.test(value) ? value : "";
    }
    // Fonction pour extraire la première date d'une chaîne et la convertir en objet Date
    static extractFirstDate(dateStr) {
        // Regex pour trouver la première date (ex: "26 janvier 2025")
        const moisMap = {
            "janvier": 0, "fevrier": 1, "mars": 2, "avril": 3, "mai": 4, "juin": 5,
            "juillet": 6, "aout": 7, "septembre": 8, "octobre": 9, "novembre": 10, "décembre": 11
        };
        const regex = /(\d{1,2}) (\w+) (\d{4})/;
        const normalizedDateStr = dateStr.normalize("NFD").replace(/[\u0300-\u036f]/g, ""); // Remove accents
        const match = normalizedDateStr.match(regex);
        if (match) {
            const [, day, month, year] = match;
            const moisIndex = moisMap[month.toLowerCase()];
            if (moisIndex !== undefined) {
                return new Date(parseInt(year), moisIndex, parseInt(day));
            }
        }
        return null;
    }
    ;
}
exports.RangeDateProperty = RangeDateProperty;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxsZW9kdVxcRG9jdW1lbnRzXFwxIC0gUHJvXFxUZXN0IHBsdWdpbiBvYnNpZGlhblxcLm9ic2lkaWFuXFxwbHVnaW5zXFxvYnNpZGlhbi1DUk1cXGR5bmFtaWMtZmllbGRzXFxzcmNcXHByb3BlcnRpZXNcXFJhbmdlRGF0ZVByb3BlcnR5LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDBEQUFrQztBQUNsQyxxQ0FBbUM7QUFDbkMsaURBQThDO0FBRzlDLE1BQWEsaUJBQWtCLFNBQVEsMkJBQVk7SUFHL0MsWUFBWSxJQUFZLEVBQUUsSUFBSSxHQUFHLEVBQUU7UUFDL0IsS0FBSyxDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFGVixTQUFJLEdBQVksV0FBVyxDQUFDO0lBRzVDLENBQUM7SUFFUSxlQUFlLENBQUMsS0FBYSxFQUFFLE1BQXdDLEVBQUUsSUFBb0I7UUFDbEcsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM5QyxLQUFLLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQztRQUNwQixLQUFLLENBQUMsS0FBSyxHQUFHLEtBQUssSUFBSSxFQUFFLENBQUMsQ0FBRSwyQ0FBMkM7UUFDdkUsS0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFbkMsSUFBQSxtQkFBUyxFQUFDLEtBQUssRUFBRTtZQUNiLFVBQVUsRUFBRSxPQUFPLEVBQUcsMEJBQTBCO1lBQ2hELFdBQVcsRUFBRSxLQUFLLElBQUksRUFBRTtZQUN4QixNQUFNLEVBQUUsSUFBSSxFQUFHLHNEQUFzRDtZQUNyRSxJQUFJLEVBQUUsT0FBTyxFQUFHLDRDQUE0QztZQUM1RCxRQUFRLEVBQUUsS0FBSyxFQUFFLGFBQXFCLEVBQUUsRUFBRTtnQkFDdEMsSUFBSSxhQUFhLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO29CQUM3QixNQUFNLFNBQVMsR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFD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SyxFQUFFLENBQUM7WUFDUixNQUFNLENBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQztZQUNuQyxNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7WUFFL0MsSUFBSSxTQUFTLEtBQUssU0FBUyxFQUFFLENBQUM7Z0JBQzlCLE9BQU8sSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLFNBQVMsRUFBRSxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMxRCxDQUFDO1FBQ0wsQ0FBQztRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ1osQ0FBQztJQUFBLENBQUM7Q0FDTDtBQXpJRCw4Q0F5SUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsZW9kdVxcRG9jdW1lbnRzXFwxIC0gUHJvXFxUZXN0IHBsdWdpbiBvYnNpZGlhblxcLm9ic2lkaWFuXFxwbHVnaW5zXFxvYnNpZGlhbi1DUk1cXGR5bmFtaWMtZmllbGRzXFxzcmNcXHByb3BlcnRpZXNcXFJhbmdlRGF0ZVByb3BlcnR5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmbGF0cGlja3IgZnJvbSBcImZsYXRwaWNrclwiO1xyXG5pbXBvcnQgXCJmbGF0cGlja3IvZGlzdC9sMTBuL2ZyLmpzXCI7XHJcbmltcG9ydCB7IERhdGVQcm9wZXJ0eSB9IGZyb20gXCIuL0RhdGVQcm9wZXJ0eVwiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBSYW5nZURhdGVQcm9wZXJ0eSBleHRlbmRzIERhdGVQcm9wZXJ0eSB7XHJcblxyXG4gICAgcHVibGljIG92ZXJyaWRlIHR5cGUgOiBzdHJpbmcgPSBcImRhdGVSYW5nZVwiO1xyXG4gICAgY29uc3RydWN0b3IobmFtZTogc3RyaW5nLCBhcmdzID0ge30pIHtcclxuICAgICAgICBzdXBlcihuYW1lLCBbXSwgYXJncyk7XHJcbiAgICB9XHJcblxyXG4gICAgb3ZlcnJpZGUgY3JlYXRlRmllbGREYXRlKHZhbHVlOiBzdHJpbmcsIHVwZGF0ZTogKHZhbHVlOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4sIGxpbms6IEhUTUxEaXZFbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcbiAgICAgICAgaW5wdXQudHlwZSA9IFwidGV4dFwiO1xyXG4gICAgICAgIGlucHV0LnZhbHVlID0gdmFsdWUgfHwgXCJcIjsgIC8vIEZvcm1hdMOpIGVuIFwiWVlZWS1NTS1ERFwiIHBvdXIgbGUgc3RvY2thZ2VcclxuICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKFwiZmllbGQtaW5wdXRcIik7XHJcbiAgICBcclxuICAgICAgICBmbGF0cGlja3IoaW5wdXQsIHtcclxuICAgICAgICAgICAgZGF0ZUZvcm1hdDogXCJZLW0tZFwiLCAgLy8gU3RvY2tlciBlbiBcIllZWVktTU0tRERcIlxyXG4gICAgICAgICAgICBkZWZhdWx0RGF0ZTogdmFsdWUgfHwgXCJcIixcclxuICAgICAgICAgICAgbG9jYWxlOiBcImZyXCIsICAvLyBVdGlsaXNhdGlvbiBkZSBsYSBsYW5ndWUgZnJhbsOnYWlzZSBwb3VyIGwnYWZmaWNoYWdlXHJcbiAgICAgICAgICAgIG1vZGU6IFwicmFuZ2VcIiwgIC8vIFBlcm1ldCBkZSBzw6lsZWN0aW9ubmVyIHVuZSBwbGFnZSBkZSBkYXRlc1xyXG4gICAgICAgICAgICBvbkNoYW5nZTogYXN5bmMgKHNlbGVjdGVkRGF0ZXM6IERhdGVbXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnREYXRlID0gc2VsZWN0ZWREYXRlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmREYXRlID0gc2VsZWN0ZWREYXRlc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnREYXRlICYmIGVuZERhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWV0IMOgIGpvdXIgbGEgdmFsZXVyIGRlIGwnaW5wdXQgYXZlYyBsZSBmb3JtYXQgXCJZWVlZLU1NLUREIHRvIFlZWVktTU0tRERcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnREYXRlLmdldFRpbWUoKSA9PT0gZW5kRGF0ZS5nZXRUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnZhbHVlID0gdGhpcy5mb3JtYXREYXRlRm9yU3RvcmFnZShzdGFydERhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBgJHt0aGlzLmZvcm1hdERhdGVGb3JTdG9yYWdlKHN0YXJ0RGF0ZSl9IHRvICR7dGhpcy5mb3JtYXREYXRlRm9yU3RvcmFnZShlbmREYXRlKX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlRmllbGQodXBkYXRlLCBpbnB1dCwgbGluayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbkNsb3NlOiBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLnVwZGF0ZUZpZWxkKHVwZGF0ZSwgaW5wdXQsIGxpbmspXHJcbiAgICAgICAgfSk7XHJcbiAgICBcclxuICAgICAgICByZXR1cm4gaW5wdXQ7XHJcbiAgICB9XHJcbiAgICAvLyBDcsOpZSB1biBsaWVuIHF1aSBhZmZpY2hlIGxhIHBsYWdlIGRlIGRhdGVzIChhdSBmb3JtYXQgXCIyNiBmw6l2cmllciAyMDI1IGF1IDI4IGbDqXZyaWVyIDIwMjVcIilcclxuICAgIG92ZXJyaWRlIGNyZWF0ZUZpZWxkTGluayh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgbGluay50ZXh0Q29udGVudCA9IHZhbHVlID8gdGhpcy5mb3JtYXREYXRlUmFuZ2VGb3JEaXNwbGF5KHZhbHVlKSA6IFwiQXVjdW5lIGRhdGUgc8OpbGVjdGlvbm7DqWVcIjtcclxuICAgICAgICBsaW5rLmNsYXNzTGlzdC5hZGQoXCJkYXRlLWZpZWxkLWxpbmtcIik7XHJcbiAgICAgICAgbGluay5jbGFzc0xpc3QuYWRkKFwiZmllbGQtbGlua1wiKTtcclxuICAgICAgICBsaW5rLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiO1xyXG4gICAgICAgIGxpbmsub25jbGljayA9IChldmVudCkgPT4gdGhpcy5tb2RpZnlGaWVsZChldmVudCk7XHJcbiAgICAgICAgcmV0dXJuIGxpbms7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRm9ybWF0ZSBsYSBwbGFnZSBkZSBkYXRlcyBwb3VyIGwnYWZmaWNoYWdlIDogXCIyNiBmw6l2cmllciAyMDI1XCIgb3UgXCIyNiBmw6l2cmllciAyMDI1IGF1IDI4IGbDqXZyaWVyIDIwMjVcIlxyXG4gICAgZm9ybWF0RGF0ZVJhbmdlRm9yRGlzcGxheShkYXRlUmFuZ2U6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgW3N0YXJ0RGF0ZSwgZW5kRGF0ZV0gPSBkYXRlUmFuZ2Uuc3BsaXQoXCIgdG8gXCIpO1xyXG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFN0YXJ0RGF0ZSA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSkudG9Mb2NhbGVEYXRlU3RyaW5nKFwiZnItRlJcIiwgeyBcclxuICAgICAgICAgICAgd2Vla2RheTogXCJsb25nXCIsXHJcbiAgICAgICAgICAgIGRheTogXCJudW1lcmljXCIsIFxyXG4gICAgICAgICAgICBtb250aDogXCJsb25nXCIsIFxyXG4gICAgICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIiBcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWVuZERhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAke2Zvcm1hdHRlZFN0YXJ0RGF0ZX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRFbmREYXRlID0gbmV3IERhdGUoZW5kRGF0ZSkudG9Mb2NhbGVEYXRlU3RyaW5nKFwiZnItRlJcIiwgeyBcclxuICAgICAgICAgICAgd2Vla2RheTogXCJsb25nXCIsXHJcbiAgICAgICAgICAgIGRheTogXCJudW1lcmljXCIsIFxyXG4gICAgICAgICAgICBtb250aDogXCJsb25nXCIsIFxyXG4gICAgICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIiBcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gYCR7Zm9ybWF0dGVkU3RhcnREYXRlfSBhdSAke2Zvcm1hdHRlZEVuZERhdGV9YDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcsOpZSB1biBjb250ZW5ldXIgcG91ciBhZmZpY2hlciBsYSBwbGFnZSBkZSBkYXRlcyBldCBsYSBzw6lsZWN0aW9uIHJhcGlkZVxyXG4gICAgb3ZlcnJpZGUgY3JlYXRlRmllbGRDb250YWluZXJDb250ZW50KHVwZGF0ZTogKHZhbHVlOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD4sIHZhbHVlOiBzdHJpbmcpOiBIVE1MRGl2RWxlbWVudCB7XHJcbiAgICAgICAgY29uc3QgZmllbGRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgIGZpZWxkQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmaWVsZC1jb250YWluZXJcIik7XHJcbiAgICAgICAgZmllbGRDb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1ldGFkYXRhLWZpZWxkXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50RmllbGQgPSB2YWx1ZTtcclxuICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5jcmVhdGVGaWVsZExpbmsoY3VycmVudEZpZWxkKTtcclxuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuY3JlYXRlRmllbGREYXRlKGN1cnJlbnRGaWVsZCwgdXBkYXRlLCBsaW5rKTtcclxuXHJcbiAgICAgICAgLy8gQWZmaWNoYWdlIGluaXRpYWwgOiBTaSBsYSBwbGFnZSBkZSBkYXRlcyBleGlzdGUsIGFmZmljaGVyIGxlIGxpZW5cclxuICAgICAgICBpZiAoY3VycmVudEZpZWxkICYmIHRoaXMudmFsaWRhdGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGxpbmsuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgICAgICAgICAgaW5wdXQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlucHV0LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgICAgICAgIGxpbmsuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZmllbGRDb250YWluZXIuYXBwZW5kQ2hpbGQobGluayk7XHJcbiAgICAgICAgZmllbGRDb250YWluZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cclxuICAgICAgICByZXR1cm4gZmllbGRDb250YWluZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWV0IMOgIGpvdXIgbGEgdmFsZXVyIGRlIGxhIHBsYWdlIGRlIGRhdGVzIGV0IGJhc2N1bGUgbCdhZmZpY2hhZ2UgZW50cmUgbGUgbGllbiBldCBsJ2lucHV0XHJcbiAgICBvdmVycmlkZSBhc3luYyB1cGRhdGVGaWVsZCh1cGRhdGU6ICh2YWx1ZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+LCBpbnB1dDogSFRNTElucHV0RWxlbWVudCwgbGluazogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLnZhbGlkYXRlKGlucHV0LnZhbHVlKTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgYXdhaXQgdXBkYXRlKHZhbHVlKTsgIC8vIE1ldCDDoCBqb3VyIGF2ZWMgbGEgcGxhZ2UgZGUgZGF0ZXMgYXUgZm9ybWF0IFwiWVlZWS1NTS1ERCB0byBZWVlZLU1NLUREXCJcclxuICAgICAgICAgICAgaW5wdXQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgICAgICBsaW5rLnRleHRDb250ZW50ID0gdGhpcy5mb3JtYXREYXRlUmFuZ2VGb3JEaXNwbGF5KHZhbHVlKTsgIC8vIEFmZmljaGFnZSBhdmVjIGxlIG1vaXMgZW4gbGV0dHJlc1xyXG4gICAgICAgICAgICBsaW5rLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXdhaXQgdXBkYXRlKGlucHV0LnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVmFsaWRlIGxhIHBsYWdlIGRlIGRhdGVzIGF1IGZvcm1hdCBcIllZWVktTU0tREQgdG8gWVlZWS1NTS1ERFwiXHJcbiAgICBvdmVycmlkZSB2YWxpZGF0ZSh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBjb25zdCBkYXRlUmFuZ2VSZWdleCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0oIHRvIFxcZHs0fS1cXGR7Mn0tXFxkezJ9KT8kLztcclxuICAgICAgICByZXR1cm4gZGF0ZVJhbmdlUmVnZXgudGVzdCh2YWx1ZSkgPyB2YWx1ZSA6IFwiXCI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEZvbmN0aW9uIHBvdXIgZXh0cmFpcmUgbGEgcHJlbWnDqHJlIGRhdGUgZCd1bmUgY2hhw65uZSBldCBsYSBjb252ZXJ0aXIgZW4gb2JqZXQgRGF0ZVxyXG4gICAgcHVibGljIHN0YXRpYyBleHRyYWN0Rmlyc3REYXRlIChkYXRlU3RyOiBzdHJpbmcpOiBEYXRlIHwgbnVsbCB7XHJcbiAgICAvLyBSZWdleCBwb3VyIHRyb3V2ZXIgbGEgcHJlbWnDqHJlIGRhdGUgKGV4OiBcIjI2IGphbnZpZXIgMjAyNVwiKVxyXG4gICAgY29uc3QgbW9pc01hcDogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHtcclxuICAgICAgICBcImphbnZpZXJcIjogMCwgXCJmZXZyaWVyXCI6IDEsIFwibWFyc1wiOiAyLCBcImF2cmlsXCI6IDMsIFwibWFpXCI6IDQsIFwianVpblwiOiA1LFxyXG4gICAgICAgIFwianVpbGxldFwiOiA2LCBcImFvdXRcIjogNywgXCJzZXB0ZW1icmVcIjogOCwgXCJvY3RvYnJlXCI6IDksIFwibm92ZW1icmVcIjogMTAsIFwiZMOpY2VtYnJlXCI6IDExXHJcbiAgICAgIH07XHJcbiAgICBjb25zdCByZWdleCA9IC8oXFxkezEsMn0pIChcXHcrKSAoXFxkezR9KS87XHJcbiAgICBjb25zdCBub3JtYWxpemVkRGF0ZVN0ciA9IGRhdGVTdHIubm9ybWFsaXplKFwiTkZEXCIpLnJlcGxhY2UoL1tcXHUwMzAwLVxcdTAzNmZdL2csIFwiXCIpOyAvLyBSZW1vdmUgYWNjZW50c1xyXG4gICAgY29uc3QgbWF0Y2ggPSBub3JtYWxpemVkRGF0ZVN0ci5tYXRjaChyZWdleCk7XHJcbiAgICBcclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IFssIGRheSwgbW9udGgsIHllYXJdID0gbWF0Y2g7XHJcbiAgICAgICAgY29uc3QgbW9pc0luZGV4ID0gbW9pc01hcFttb250aC50b0xvd2VyQ2FzZSgpXTtcclxuICAgIFxyXG4gICAgICAgIGlmIChtb2lzSW5kZXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShwYXJzZUludCh5ZWFyKSwgbW9pc0luZGV4LCBwYXJzZUludChkYXkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxufVxyXG4iXSwidmVyc2lvbiI6M30=