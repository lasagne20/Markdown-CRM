{"file":"C:\\Users\\leodu\\Documents\\1 - Pro\\Test plugin obsidian\\.obsidian\\plugins\\obsidian-CRM\\dynamic-fields\\__tests__\\vault\\Vault.test.ts","mappings":"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","names":[],"sources":["C:\\Users\\leodu\\Documents\\1 - Pro\\Test plugin obsidian\\.obsidian\\plugins\\obsidian-CRM\\dynamic-fields\\__tests__\\vault\\Vault.test.ts"],"sourcesContent":["import { Vault } from '../../src/vault/Vault';\r\nimport { MockApp, mockApp } from '../mocks';\r\n\r\ndescribe('Vault', () => {\r\n    let vault: Vault;\r\n    let app: MockApp;\r\n\r\n    beforeEach(() => {\r\n        // Reset all mocks\r\n        jest.clearAllMocks();\r\n        \r\n        // Create fresh instances\r\n        app = mockApp();\r\n        vault = new Vault(app as any);\r\n    });\r\n\r\n    describe('constructor', () => {\r\n        it('should create vault instance with app', () => {\r\n            expect(vault).toBeInstanceOf(Vault);\r\n            expect(vault.app).toBe(app);\r\n        });\r\n    });\r\n\r\n    describe('getAllFilesInFolder', () => {\r\n        it('should return empty array for non-existent folder', () => {\r\n            app.vault.getAbstractFileByPath.mockReturnValue(null);\r\n            \r\n            const files = vault.getAllFilesInFolder('non-existent');\r\n            \r\n            expect(files).toEqual([]);\r\n        });\r\n\r\n        it('should return empty array for file instead of folder', () => {\r\n            const mockFile = { children: undefined };\r\n            app.vault.getAbstractFileByPath.mockReturnValue(mockFile as any);\r\n            \r\n            const files = vault.getAllFilesInFolder('file.md');\r\n            \r\n            expect(files).toEqual([]);\r\n        });\r\n\r\n        it('should return files from folder', () => {\r\n            const mockFile1 = { path: 'folder/file1.md' };\r\n            const mockFile2 = { path: 'folder/file2.md' };\r\n            const mockSubfolder = { \r\n                children: [mockFile1, mockFile2] as any\r\n            };\r\n            \r\n            app.vault.getAbstractFileByPath.mockReturnValue(mockSubfolder as any);\r\n            \r\n            const files = vault.getAllFilesInFolder('folder');\r\n            \r\n            expect(files).toEqual([mockFile1, mockFile2]);\r\n        });\r\n    });\r\n\r\n    describe('fileExists', () => {\r\n        it('should return true if file exists', () => {\r\n            app.vault.getAbstractFileByPath.mockReturnValue({ path: 'test.md' } as any);\r\n            \r\n            expect(vault.fileExists('test.md')).toBe(true);\r\n        });\r\n\r\n        it('should return false if file does not exist', () => {\r\n            app.vault.getAbstractFileByPath.mockReturnValue(null);\r\n            \r\n            expect(vault.fileExists('test.md')).toBe(false);\r\n        });\r\n    });\r\n\r\n    describe('getFilesWithExtension', () => {\r\n        beforeEach(() => {\r\n            const mockFiles = [\r\n                { path: 'file1.md', extension: 'md' },\r\n                { path: 'file2.txt', extension: 'txt' },\r\n                { path: 'file3.md', extension: 'md' },\r\n                { path: 'file4.pdf', extension: 'pdf' }\r\n            ];\r\n            \r\n            app.vault.getFiles.mockReturnValue(mockFiles as any);\r\n        });\r\n\r\n        it('should return files with specified extension', () => {\r\n            const mdFiles = vault.getFilesWithExtension('md');\r\n            \r\n            expect(mdFiles).toHaveLength(2);\r\n            expect(mdFiles.every(file => file.extension === 'md')).toBe(true);\r\n        });\r\n\r\n        it('should return empty array for non-existent extension', () => {\r\n            const jsFiles = vault.getFilesWithExtension('js');\r\n            \r\n            expect(jsFiles).toHaveLength(0);\r\n        });\r\n\r\n        it('should be case sensitive', () => {\r\n            const mdFiles = vault.getFilesWithExtension('MD');\r\n            \r\n            expect(mdFiles).toHaveLength(0);\r\n        });\r\n    });\r\n\r\n    describe('getFileByPath', () => {\r\n        it('should return file if exists', () => {\r\n            const mockFile = { path: 'test.md' };\r\n            app.vault.getAbstractFileByPath.mockReturnValue(mockFile as any);\r\n            \r\n            const result = vault.getFileByPath('test.md');\r\n            \r\n            expect(result).toBe(mockFile);\r\n        });\r\n\r\n        it('should return null if file does not exist', () => {\r\n            app.vault.getAbstractFileByPath.mockReturnValue(null);\r\n            \r\n            const result = vault.getFileByPath('test.md');\r\n            \r\n            expect(result).toBeNull();\r\n        });\r\n    });\r\n\r\n    describe('createFolder', () => {\r\n        it('should create folder if it does not exist', async () => {\r\n            app.vault.getAbstractFileByPath.mockReturnValue(null);\r\n            app.vault.createFolder.mockResolvedValue({} as any);\r\n            \r\n            await vault.createFolder('new-folder');\r\n            \r\n            expect(app.vault.createFolder).toHaveBeenCalledWith('new-folder');\r\n        });\r\n\r\n        it('should not create folder if it already exists', async () => {\r\n            app.vault.getAbstractFileByPath.mockReturnValue({} as any);\r\n            \r\n            await vault.createFolder('existing-folder');\r\n            \r\n            expect(app.vault.createFolder).not.toHaveBeenCalled();\r\n        });\r\n    });\r\n});"],"version":3}