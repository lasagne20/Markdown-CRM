{"file":"C:\\Users\\leodu\\Documents\\1 - Pro\\Test plugin obsidian\\.obsidian\\plugins\\obsidian-CRM\\dynamic-fields\\src\\vault\\Utils.ts","mappings":";AAAA,iDAAiD;;;AAE1C,MAAM,yBAAyB,GAAG,KAAK,EAC1C,GAAQ,EACR,QAAgB,EAChB,GAAW,EACX,QAA6B,EAChB,EAAE;IACf,8DAA8D;IAC9D,gFAAgF;IAChF,IAAI,QAAQ,GAAG,CAAC,CAAC;IACjB,MAAM,WAAW,GAAG,EAAE,CAAC;IAEvB,OAAO,QAAQ,GAAG,WAAW,EAAE,CAAC;QAC5B,MAAM,IAAI,GAAG,GAAG,CAAC,KAAK,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC;QACvD,IAAI,IAAI,EAAE,CAAC;YACP,MAAM,QAAQ,GAAG,GAAG,CAAC,aAAa,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE,WAAW,CAAC;YACnE,IAAI,QAAQ,IAAI,QAAQ,CAAC,GAAG,CAAC,KAAK,SAAS,EAAE,CAAC;gBAC1C,MAAM,QAAQ,EAAE,CAAC;gBACjB,OAAO;YACX,CAAC;QACL,CAAC;QAED,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,CAAC;QACvD,QAAQ,EAAE,CAAC;IACf,CAAC;IAED,iFAAiF;IACjF,MAAM,QAAQ,EAAE,CAAC;AACrB,CAAC,CAAC;AA3BW,QAAA,yBAAyB,6BA2BpC;AAEK,MAAM,0BAA0B,GAAG,KAAK,EAC3C,GAAQ,EACR,QAA6B,EAChB,EAAE;IACf,wDAAwD;IACxD,kCAAkC;IAClC,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,CAAC;IACvD,MAAM,QAAQ,EAAE,CAAC;AACrB,CAAC,CAAC;AARW,QAAA,0BAA0B,8BAQrC;AAEK,MAAM,OAAO,GAAG,CACnB,SAAsB,EACtB,QAAgB,EACZ,EAAE;IACN,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;AAC/E,CAAC,CAAC;AALW,QAAA,OAAO,WAKlB;AAEK,MAAM,UAAU,GAAG,CAAC,OAAe,EAAE,OAAqC,MAAM,EAAQ,EAAE;IAC7F,MAAM,IAAI,KAAK,CAAC,wDAAwD,CAAC,CAAC;AAC9E,CAAC,CAAC;AAFW,QAAA,UAAU,cAErB;AAEK,MAAM,UAAU,GAAG,KAAK,EAAE,KAAU,EAAE,OAAiB,EAAE,OAAY,EAAgB,EAAE;IAC1F,MAAM,IAAI,KAAK,CAAC,4DAA4D,CAAC,CAAC;AAClF,CAAC,CAAC;AAFW,QAAA,UAAU,cAErB","names":[],"sources":["C:\\Users\\leodu\\Documents\\1 - Pro\\Test plugin obsidian\\.obsidian\\plugins\\obsidian-CRM\\dynamic-fields\\src\\vault\\Utils.ts"],"sourcesContent":["// Utility functions for file metadata operations\r\n\r\nexport const waitForFileMetaDataUpdate = async (\r\n    app: any,\r\n    filePath: string,\r\n    key: string,\r\n    callback: () => Promise<void>\r\n): Promise<void> => {\r\n    // Attendre que les métadonnées du fichier soient mises à jour\r\n    // Dans un environnement réel, ceci surveillerait les changements de métadonnées\r\n    let attempts = 0;\r\n    const maxAttempts = 50;\r\n    \r\n    while (attempts < maxAttempts) {\r\n        const file = app.vault.getAbstractFileByPath(filePath);\r\n        if (file) {\r\n            const metadata = app.metadataCache.getFileCache(file)?.frontmatter;\r\n            if (metadata && metadata[key] !== undefined) {\r\n                await callback();\r\n                return;\r\n            }\r\n        }\r\n        \r\n        await new Promise(resolve => setTimeout(resolve, 100));\r\n        attempts++;\r\n    }\r\n    \r\n    // Si on n'arrive pas à détecter le changement, on exécute quand même le callback\r\n    await callback();\r\n};\r\n\r\nexport const waitForMetaDataCacheUpdate = async (\r\n    app: any,\r\n    callback: () => Promise<void>\r\n): Promise<void> => {\r\n    // Attendre que le cache des métadonnées soit mis à jour\r\n    // Simulation d'une attente courte\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n    await callback();\r\n};\r\n\r\nexport const setIcon = (\r\n    container: HTMLElement,\r\n    iconName: string\r\n): void => {\r\n    throw new Error(\"setIcon function is not implemented in this environment\");\r\n};\r\n\r\nexport const sendNotice = (message: string, type: \"info\" | \"success\" | \"error\" = \"info\"): void => {\r\n    throw new Error(\"Notice function is not implemented in this environment\");\r\n};\r\n\r\nexport const selectFile = async (vault: any, classes: string[], options: any): Promise<any> => {\r\n    throw new Error(\"selectFile function is not implemented in this environment\");\r\n};"],"version":3}