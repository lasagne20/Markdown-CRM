{"file":"C:\\Users\\leodu\\Documents\\1 - Pro\\Test plugin obsidian\\.obsidian\\plugins\\obsidian-CRM\\dynamic-fields\\src\\vault\\Vault.ts","mappings":"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","names":[],"sources":["C:\\Users\\leodu\\Documents\\1 - Pro\\Test plugin obsidian\\.obsidian\\plugins\\obsidian-CRM\\dynamic-fields\\src\\vault\\Vault.ts"],"sourcesContent":["import { DynamicClassFactory } from \"../Config/DynamicClassFactory\";\r\nimport { IApp, IFile } from \"../interfaces/IApp\";\r\nimport { Classe } from \"./Classe\";\r\nimport { File } from \"./File\";\r\n\r\nexport interface Settings {\r\n  templateFolder: string;\r\n  personalName : string;\r\n  configPath?: string; // Path to YAML configuration files\r\n}\r\n\r\nexport class Vault {\r\n    /*\r\n    Global Vault, with all informations\r\n    */\r\n    public app: IApp;\r\n    \r\n    public settings: Settings;\r\n    public files: { [key: string]: Classe } = {};\r\n\r\n    public static classes: { [key: string]: typeof Classe };\r\n    private static dynamicClassFactory: DynamicClassFactory | null = null;\r\n\r\n    constructor(app: IApp, settings: Settings) {\r\n        this.app = app;\r\n        this.settings = settings;\r\n        // Initialize the dynamic class factory\r\n        this.initializeDynamicClasses();\r\n    }\r\n\r\n    public getPath(): string {\r\n        return this.app.getVaultPath();\r\n    }\r\n\r\n    public getName(): string {\r\n        return this.app.getName();\r\n    }\r\n\r\n\r\n    private async initializeDynamicClasses() {\r\n        try {\r\n            const configPath = this.settings.configPath || './config';\r\n            Vault.dynamicClassFactory = new DynamicClassFactory(configPath, this);\r\n            \r\n            // Load available classes and populate the static classes object\r\n            const availableClasses = await Vault.dynamicClassFactory.getAvailableClasses();\r\n            for (const className of availableClasses) {\r\n                const dynamicClass = await Vault.dynamicClassFactory.getClass(className);\r\n                Vault.classes[className] = dynamicClass;\r\n            }\r\n        } catch (error) {\r\n            console.error('Failed to initialize dynamic classes:', error);\r\n        }\r\n    }\r\n\r\n    getDynamicClassFactory(): DynamicClassFactory | null {\r\n        return Vault.dynamicClassFactory;\r\n    }\r\n\r\n    getPersonalName(){\r\n        return this.settings.personalName\r\n    }\r\n\r\n    getClasseFromName(name: string) : typeof Classe{\r\n        return Vault.classes[name]\r\n    }\r\n\r\n    readLinkFile(link: string, path = false): string {\r\n        if (!link || typeof link !== \"string\") return \"\";\r\n        // Match [[file|alias]] or [[file]]\r\n        const match = link.match(/^\\[\\[([^\\|\\]]+?)(?:)?(?:\\|([^\\]]+))?\\]\\]$/);\r\n        if (match) {\r\n            const fileName = match[1]?.trim();\r\n            const alias = match[2]?.trim();\r\n            if (path) {\r\n                return /\\.[^\\/\\\\]+$/.test(fileName) ? fileName : `${fileName}.md`;\r\n            } else {\r\n                return alias ? alias : fileName.split(\"/\").pop()?.replace(\".md\",\"\") || \"\";\r\n            }\r\n        }\r\n        // If not a wikilink, just return the trimmed link\r\n        return link.trim();\r\n    }\r\n\r\n    async getFromLink(name: string, log=true) {\r\n        if (!name) { return null; }\r\n\r\n        // Search with the path\r\n        let path = this.readLinkFile(name, true);\r\n        let directfile = (await this.app.listFiles()).find((f : IFile) => {\r\n            return f.path.trim() === path.trim()\r\n        });\r\n        if (directfile) {\r\n            if (directfile.path in Object.keys(this.files)) {\r\n                return this.files[directfile.path];\r\n            }\r\n            return await this.createClasse(directfile);\r\n        }\r\n\r\n\r\n        let fileName = path.split(\"/\").pop() || \"\";\r\n        const files = (await this.app.listFiles()).filter((f : IFile) => f.name === fileName);\r\n        if (files.length > 0) {\r\n            let file = files[0];\r\n            if (files.length > 1) {\r\n                let path = this.readLinkFile(name, true);\r\n                if (path) {\r\n                    // Try to find the best match by walking up the path segments\r\n                    let segments = path.split(\"/\");\r\n                    while (segments.length > 0) {\r\n                        const candidatePath = segments.join(\"/\");\r\n                        const bestMatch = files.find((f : IFile) => f.path.endsWith(\"/\" + candidatePath) || f.path === candidatePath);\r\n                        if (bestMatch) {\r\n                            file = bestMatch;\r\n                            break;\r\n                        }\r\n                        segments.shift(); // Remove the first segment and try again\r\n                    }\r\n                }\r\n                else {\r\n                    console.error(\"Plusieurs fichiers trouvés pour le lien sans chemin : \" + name, files);\r\n                }\r\n            }\r\n\r\n            if (file.path in Object.keys(this.files)) {\r\n                return this.files[file.path];\r\n            }\r\n            return await this.createClasse(file);\r\n        }\r\n        if (log) {\r\n            console.error(\"Fichier non trouvé : \" + name);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    async getMediaFromLink(link: string) {\r\n        let path = this.readLinkFile(link, true);\r\n        const file = (await this.app.listFiles()).find((f : IFile) => {\r\n            return f.path === path});\r\n        if (file) {\r\n            return file;\r\n        }\r\n\r\n        // try with the file name\r\n        let fileName = this.readLinkFile(link);\r\n        const files = (await this.app.listFiles()).filter((f : IFile) => f.name === fileName);\r\n        if (files.length > 0) {\r\n            let file = files[0];\r\n            if (files.length > 1) {\r\n                console.error(\"Plusieurs fichiers trouvés pour le lien sans chemin : \" + link, files);\r\n            }\r\n            return file;\r\n        }\r\n\r\n        console.error(\"Media non trouvé : \" + link);\r\n        return null;\r\n    }\r\n\r\n    /*\r\n    getFromFolder(folder: Folder) {\r\n        let name = folder.path.split(\"/\")[folder.path.split(\"/\").length - 1];\r\n        for (let file of folder.children || []) {\r\n            if (this.app.isTFile(file) && file.name.includes(name)) {\r\n                return this.getFromFile(file);\r\n            }\r\n        }\r\n        console.error(\"Le dossier n'a pas de fichier classe : \" + folder.path);\r\n    }*/\r\n\r\n    async getFromFile(file: IFile): Promise<Classe | undefined> {\r\n        if (this.app.isFolder(file)) {\r\n            let filePath = file.path + \"/\" + file.name;\r\n            let iFile = await this.app.getFile(filePath)\r\n            if (!iFile) {\r\n                console.error(\"Le dossier n'a pas de fichier classe : \" + file.path);\r\n                return undefined;\r\n            }\r\n        }\r\n\r\n        let existingClass = this.files[file.path];\r\n        if (existingClass) { return existingClass; }\r\n        \r\n        let classe: Classe | undefined;\r\n        \r\n        classe = await this.createClasse(file);\r\n\r\n        return classe;\r\n\r\n    }\r\n\r\n    async createFile(classeType: null | typeof Classe = null, name: string = \"\", args: {parent? : Classe} = {}): Promise<File | undefined> {\r\n        // Create the new file from the className template\r\n        if (!classeType) {\r\n            const dynamicClasses = Object.keys(Vault.classes);\r\n            classeType = await this.app.selectClasse(this, dynamicClasses, \"Quelle classe pour ce fichier ?\");\r\n            if (!classeType) { return; }\r\n        }\r\n        console.log(\"Args ; \",args)\r\n        if (!name) {\r\n            let classe = await this.app.selectFile(this, [classeType.name], {hint:\"Entrer un nom pour ce fichier\", classeArgs: args});\r\n            // Select File call createFile if the file doesn't exist\r\n            // No need to continue\r\n            return classe?.file;\r\n        }\r\n        let templatePath = this.settings.templateFolder + \"/\" + classeType.name + \".md\";\r\n        const templateFile = await this.app.getFile(templatePath);\r\n        const newFilePath = name.includes(\".md\") ? name : `${name}.md`;\r\n        let templateContent = \"---\\nClasse: \" + classeType.name + \"\\n---\\n\";\r\n\r\n        if (templateFile && (await this.app.isFile(templateFile))) {\r\n            templateContent = await this.app.readFile(templateFile);\r\n        } else {\r\n            console.warn(\"Le fichier template n'existe pas :\" + templatePath + \". Un fichier vide sera créé.\");\r\n        }\r\n        let file: File | null = null;\r\n        try {\r\n            file = new File(this, await this.app.createFile(newFilePath, templateContent));\r\n            console.log(\"Nouveau fichier créé : \" + newFilePath);\r\n        } catch (error) {\r\n            // Modifier le fichier s'il existe déjà\r\n            const file = await this.app.getFile(newFilePath);\r\n            if (!file) {\r\n                throw Error(\"Le fichier n'a pas pu être créé ou modifié : \" + newFilePath);\r\n            }\r\n            if (file && this.app.isFile(file)) {\r\n                await this.app.writeFile(file, templateContent);\r\n                console.log(\"Fichier modifié : \" + newFilePath);\r\n            } else {\r\n                throw Error(\"Le fichier n'a pas pu être créé ou modifié : \" + newFilePath);\r\n            }\r\n        }\r\n\r\n        if (!file) {\r\n            throw Error(\"Le fichier n'existe pas : \" + newFilePath);\r\n        }\r\n        \r\n        await this.app.waitForFileMetaDataUpdate(file.path, \"Classe\", async () => {\r\n            await new Promise(resolve => setTimeout(resolve, 200));\r\n            if (!file) { return; }\r\n            let classe = await this.getFromFile(file);\r\n            if (!classe) {\r\n                console.error(\"Classe non trouvée pour le fichier : \" + file.path);\r\n                return;\r\n            }\r\n            await classe.onCreate();\r\n            await classe.onUpdate();\r\n            console.log(\"Classe créée : \" + classe.name);\r\n        });\r\n        return file;\r\n    }\r\n\r\n    async refreshAll() {\r\n        // Move all files \r\n        let watchedFiles: string[] = [];\r\n        for (let file of await this.app.listFiles()) {\r\n            if (watchedFiles.includes(file.name) || file.path.startsWith(\"Outils\")) {\r\n                continue;\r\n            }\r\n            console.log(\"Refresh : \" + file.path);\r\n            const classe = await this.getFromFile(file);\r\n            if (classe) {\r\n                classe.onUpdate();\r\n            }\r\n\r\n            // Remove the duplicates\r\n            /*\r\n            for (let file2 of this.app.vault.getFiles()) {\r\n                // Compare the name\r\n                if (file.name === file2.name && file.path != file2.path && this.getFromFile(file)?.getClasse() === this.getFromFile(file2)?.getClasse()) {\r\n                    console.error(\"Doublon de \\n\" + file.path + \"\\n\" + file2.path);\r\n                    // Keep the first by default\r\n                    await this.app.vault.delete(file2);\r\n                }\r\n            }*/\r\n            watchedFiles.push(file.name);\r\n        }\r\n\r\n        // Remove empty folders \r\n        for (let folder of await this.app.listFolders()) {\r\n            if (folder.children && folder.children.length === 0) {\r\n                await this.app.delete(folder);\r\n            }\r\n        }\r\n\r\n        this.app.sendNotice(\"Vault refresh\");\r\n    }\r\n\r\n    async createClasse(file: IFile) {\r\n        let fileInstance: File;\r\n        if (!(file instanceof File)){\r\n            fileInstance = new File(this, file);\r\n        } else {\r\n            fileInstance = file;\r\n        }\r\n        \r\n        const metadata = await this.app.getMetadata(fileInstance);\r\n        if (!metadata) {\r\n            console.error(\"Pas de metadata\");\r\n            return;\r\n        }\r\n        \r\n        const className = metadata[\"Classe\"];\r\n        if (!className) {\r\n            console.error(\"Pas de classe définie dans les métadonnées\");\r\n            return undefined;\r\n        }\r\n\r\n        try {\r\n            // Use the dynamic class factory to get the constructor\r\n            if (Vault.dynamicClassFactory) {\r\n                const constructor = await Vault.dynamicClassFactory.getClass(className);\r\n                if (constructor) {\r\n                    return new constructor(this, fileInstance);\r\n                }\r\n            }\r\n            \r\n            // Fallback to static classes if dynamic factory is not available\r\n            let constructor = Vault.classes[className];\r\n            if (constructor) {\r\n                return new constructor(this, fileInstance);\r\n            }\r\n            \r\n            console.error(\"Type non connue : \" + className);\r\n            return undefined;\r\n        } catch (error) {\r\n            console.error(\"Erreur lors de la création de la classe : \" + className, error);\r\n            return undefined;\r\n        }\r\n    }\r\n}"],"version":3}